# 020-Netty中的ByteBuf

[TOC]

## ByteBuf的逻辑部分

ByteBuf是一个字节容器, 内部是一个字节数组, 从逻辑上来分, 字节容器内部可以分为四个部分

![image-20210703105813341](../../../../../assets/image-20210703105813341.png)

1. 第一部分是已用字节,表示已经使用完的废弃的无效字节
2. 第二部分是可读字节,这部分数据是ByteBuf保存的有效数据, 从ByteBuf中读取的数据都来自这一部分
3. 第三部分是可写字节,写入到ByteBuf的数据都会写到这一部分中
4. 第四部分是可扩充字节, 表示的是该ByteBuf最多还可以扩容的大小

## 为什么要这样设计

与JavaNIO的 ByteBuf相比, ByteBuf的优势如下

- Pooling 池化技术, 减少了内存复制和GC, 提高效率
- 复合缓冲区类型, 支持零拷贝
- **不需要调用flip()方法区切换读写模式**
- 拓展性好, 例如 StringBuffer
- 可以自定义缓冲区类型
- 读取和写入索引分开
- 方法的链式调用
- 可以进行引用计数, 方便重复使用

![image-20210703105740858](../../../../../assets/image-20210703105740858.png)

