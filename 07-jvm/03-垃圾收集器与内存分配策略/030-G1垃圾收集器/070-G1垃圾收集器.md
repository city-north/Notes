# 070-G1垃圾收集器

[TOC]

## 什么是G1垃圾收集器

**它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量**

G1回收器（Garbage-First）是在JDK 1.7中正式使用的全新的垃圾回收器，从长期目标来看，它是为了**取代CMS回收器**。

G1回收器拥有独特的垃圾回收策略，和之前提到的回收器截然不同。

- 从分代上看，G1依然属于分代垃圾回收器，它会区分年轻代和老年代，依然有eden区和survivor区，
- 但从堆的结构上看，它并不要求整个eden区、年轻代或者老年代都连续。
- 它使用了分区算法。作为CMS的长期替代方案，G1使用了全新的分区算法，其特点如下。

| 特性     | 详情                                                         |
| -------- | ------------------------------------------------------------ |
| 并行性   | **G1在回收期间，可以由多个GC线程同时工作，有效利用多核计算能力。** |
| 并发性   | G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般来说，不会在整个回收期间完全阻塞应用程序。 |
| 分代 GC  | G1 依然是一个分代回收器，但是和之前的回收器不同，它同时兼顾年轻代和老年代，其他回收器或者工作在年轻代，或者工作在老年代。 |
| 空间整理 | G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单地标记清理对象，在若干次GC后，CMS必须进行一次碎片整理。而G1不同，它每次回收都会有效地复制对象，减少碎片空间。 |
| 可预见性 | 由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，全局停顿也能得到较好的控制。 |

**延迟可控的情况下获得尽可能高的吞吐量**

G1(Garbage First) **延迟可控的情况下获得尽可能高的吞吐量** 是垃圾收集器技术的新思路 , JDK7 默认垃圾收集器

- 针对**停顿时间模型**
- 面向局部收集的设计思路
- [基于Region的内存布局形式](#基于Region的内存布局形式)
- 是一款 **面向服务器端应用的垃圾收集器**

## 基于Region的内存布局形式

在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），

每个Region是逻辑连续的一段内存，结构如下：

![image-20200908195159285](../../../assets/image-20200908195159285.png)

每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，

- 其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。

## G1的主要收集过程

G1将堆进行分区，划分为一个个的区域，每次回收的时候，只回收其中几个区域，以此来控制垃圾回收产生的一次停顿的时间。

- [新生代GC](#新生代GC)
- [并发标记周期](#并发标记周期)
- [混合回收](071-G1垃圾收集器-混合回收.md) 
- [如果需要,会触发FullGC](072-G1垃圾收集器-fullGC.md) 

## YoungGC

新生代GC的主要工作是回收eden区和survivor区。

一旦eden区被占满，新生代GC就会启动。新生代GC前、后的堆数据示例如图所示，其中E表示eden区，S表示survivor区，O表示老年代。

<img src="../../../assets/image-20200920214921559.png" alt="image-20200920214921559" style="zoom: 33%;" />

可以看到，新生代GC只处理eden区和survivor区，回收后所有的eden区都应该被清空，而survivor区会被回收一部分数据，但是应该至少仍然存在一个survivor区，类比其他的新生代回收器，这一点似乎并没有太大变化。

另一个重要的变化是，老年代的区域增多，因为部分survivor区或者eden区的对象可能会晋升到老年代。

如果开启了 PrintGCDetails 选项,就可以得到类似如下的GC日志

```
2020-09-10T16:44:18.677-0800: 1.312: [GC pause (Metadata GC Threshold) (young) (initial-mark), 0.0104708 secs]
   [Eden: 82.0M(300.0M)->0.0B(290.0M) Survivors: 6144.0K->16.0M Heap: 89.7M(512.0M)->17.7M(512.0M)]
```

和其他回收器的日志相比，G1的日志内容非常丰富。

当然我们最关心的依然是GC的停顿时间及回收情况。从日志中可以看到，

- eden区原本占用300MB空间，回收后被清空，
- survivor区从6144k增长到了16.0MB，这是因为部分对象被从eden区复制到survivor区，整个堆合计为512MB，堆内存从回收前的89.7MB下降到17.7MB。

## 值得注意的是

G1收集器除了并发标记之外,其余阶段也是要完全暂停用户线程的 

所以 **G1收集器并非纯粹追求低延迟,官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量,所以才能撑起<全功能收集器>的重任和期望**

G1中 堆被划分为一组大小相等的(Region)，每个区域都是连续的虚拟内存范围。

- G1执行一个并发全局标记阶段，来确定堆中对象的是否存活。
- 标记阶段完成后，G1知道哪些区域大部分是空的。它首先在这些区域进行收集，这通常会产生大量的自由空间。

这就是为什么这种垃圾收集方法被称为垃圾优先的原因。顾名思义，G1将其收集和压缩活动集中在堆中可能充满可回收对象(即垃圾)的区域。

- G1使用一个暂停预测机制来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。

被G1确定为可以回收的区域是通过疏散来收集垃圾的。G1将对象从堆的一个或多个区域复制到堆上的单个区域，并在这个过程中压缩和释放内存。此疏散在多处理器上并行执行，以减少暂停时间并提高吞吐量。因此，对于每次垃圾收集，G1都在用户定义的暂停时间内持续工作以减少碎片。这超出了前面两种方法的能力。CMS(并发标记清除)垃圾收集不执行压缩。ParallelOld垃圾收集只执行整堆压缩，这会导致相当长的暂停时间。

需要注意的是，G1不是一个实时收集器。它满足设定的暂停时间目标的概率很高，但不是绝对确定的。基于以前收集的数据，G1估计在用户指定的目标时间内可以收集多少区域。因此，收集器对于收集区域的成本有一个相当准确的模型，它使用这个模型来确定要收集哪些区域和多少区域，同时保持在暂停时间目标内。

## G1和CMS的对比

- G1 是标记整理算法, CMS是标记清除算法 减少了空间碎片

- G1计划作为并发标记-清除收集器(CMS)的长期替代品。
- 与CMS相比，G1是一个更好的解决方案。一个不同之处在于G1是一个压缩收集器。
- G1非常紧凑，完全避免了使用细粒度的空闲列表进行分配，而是依赖于区域。
- 这大大简化了收集器的各个部分，并在很大程度上消除了潜在的碎片问题。
- 此外，G1比CMS收集器提供了更多可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。

