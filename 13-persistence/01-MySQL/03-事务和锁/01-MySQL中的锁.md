# 01-MySQL中的锁

[TOC]

## MySQL锁机制简介

MySQL的锁机制比较简单,最显著的特点是不同的数据引擎支持不同的锁

- InnoDB支持行锁、表锁

- MySIAM只支持表锁

| 锁类型 | 开销   | 加锁速度 | 粒度     | 死锁         | 发生锁冲突概率     | 并发度   |
| ------ | ------ | -------- | -------- | ------------ | ------------------ | -------- |
| 表锁   | 开销小 | 加锁快   | 锁粒度大 | 不会出现死锁 | 发生冲突的概率低   | 并发度低 |
| 行锁   | 开销大 | 加锁慢   | 锁粒度小 | 会出现死锁   | 发生锁冲突的概率高 | 并发度高 |

## InnoDB 锁类型

- [读锁](#读锁)

- [写锁](#写锁)

- MDL锁

-  [意向锁](02-MySQL意向锁.md) 

- 行锁的算法(种类)

  - [RecordLocks(记录锁) ](05-MySQL记录锁.md) : 单个行记录上的锁

  - [Gap(间隙锁)](03-MySQL间隙锁.md) : 间隙锁,锁定一个范围,但是不包含记录本身

  - [单记录锁和间隙锁的组合(next-key-锁) ](04-MySQL临键锁.md) :锁定一个范围,并锁定记录本身

    > 普通索引默认的就是 next-key 锁

## 读锁

共享锁又称读锁 , 简称 S 锁, 共享锁就是多个事务对统一数据可以共享一把锁,都能访问到数据,但是只能读不能修改

加锁语法

```sql
select * from student where id = 1 LOCK IN SHARE MODE;
```

## 写锁

排它锁又称写锁,简称 X 锁, 排它锁不能与其他锁共存,如一个事务获取了一个数据行的排他锁,其他事务就不能再获取该行的锁(共享锁或者排它锁), 只有该获取了排它锁的事务是可以对数据行进行读取和修改

加锁语法

```SQL
自动 :  delete / update / insert 默认加上 X 锁
手动 : select * from student where id = 1 FOR UPDATE
```

## 锁到底锁住了什么

锁住的是索引

## 如果锁住的是索引，一张表没有索引怎么办?

- 如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。
- 如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引。

- 如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。

## 为什么通过唯一索引给数据行加锁，主键索引也会被锁住?

在辅助索引里面，索引存储的是二级索引和主键的值。

比如 name=4，存储的是 name 的索引和主键 id 的值 4。

而主键索引里面除了索引之外，还存储了完整的数据。所以我们通过辅助索引锁定 一行数据的时候，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然后也锁定。

