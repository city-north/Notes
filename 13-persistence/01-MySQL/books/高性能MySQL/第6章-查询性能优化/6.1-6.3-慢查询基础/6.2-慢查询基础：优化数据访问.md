# 6.2-慢查询基础：优化数据访问

[TOC]

## 慢查询基础：优化数据访问

查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：

1. **确认应用程序是否在检索大量超过需要的数据**。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2. **确认MySQL服务器层是否在分析大量超过需要的数据行。**

## 步骤一:优化数据访问:是否向数据库请求了不需要的数据

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销[(2)](https://www.neat-reader.cn/part0013.xhtml#ch2)，另外也会消耗应用服务器的CPU和内存资源。

### 典型案例:查询不需要的记录

一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。

最简单有效的解决方法就是在这样的查询后面加上LIMIT。

### 典型案例:多表关联时返回全部列

如果你想查询所有在电影*Academy Dinosaur*中出现的演员，千万不要按下面的写法编写查询：

```sql
SELECT
	* 
FROM
	sakila.actor
	INNER JOIN sakila.film_actor USING ( actor_id )
	INNER JOIN sakila.film USING ( film_id ) 
WHERE
	sakila.film.title = 'Academy Dinosaur';
```

这将返回这三个表的全部数据列。正确的方式应该是像下面这样只取需要的列：

```sql
SELECT
	sakila.actor.* 
FROM
	sakila.actor...;
```

## 步骤二:MySQL是否在扫描额外的记录

在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：

- 响应时间
- 扫描的行数
- 返回的行数

没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。

#### 响应时间

响应时间是两个部分之和：

- 服务时间, 是指数据库处理这个查询真正花了多长时间。
- 排队时间, 是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。

我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到。一般最常见和重要的等待是I/O和锁等待，但是实际情况更加复杂。

所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者公式。诸如存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等诸多因素都会影响响应时间。

#### 扫描的行数和返回的行数

分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。

对于找出那些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。

理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大。

#### 扫描的行数和访问类型

在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。

在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从

- 全表扫描 (ALL)
- 索引扫描 (index)
- 范围扫描 (range)
- 唯一索引查询(ref_const)
- 常数引用等(const)

如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引，这也正是我们前一章讨论过的问题。现在应该明白为什么索引对于查询优化如此重要了。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。

例如，我们看看示例数据库Sakila中的一个查询案例：

```sql
SELECT * FROM sakila.film_actor WHERE film_id = 1;
```

```sql
    mysql> EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1\G
    *************************** 1. row ***************************
               id: 1
      select_type: SIMPLE
            table: film_actor
             type: ref -- 使用非唯一索引扫描
    possible_keys: idx_fk_film_id
              key: idx_fk_film_id
          key_len: 2
              ref: const
             rows: 10
            Extra:
```

EXPLAIN的结果也显示MySQL预估需要访问10行数据。

如果没有合适的索引会怎样呢？MySQL就不得不使用一种更糟糕的访问类型，下面我们来看看如果我们删除对应的索引再来运行这个查询：

```
ALTER TABLE sakila.film_actor DROP FOREIGN KEY fk_film_actor_film;
ALTER TABLE sakila.film_actor DROP KEY idx_fk_film_id;
     EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1
```

```
 *************************** 1. row ***************************
               id: 1
      select_type: SIMPLE
            table: film_actor
             type: ALL -- 全表扫描
    possible_keys: NULL
              key: NULL
          key_len: NULL
              ref: NULL
             rows: 5073 
            Extra: Using where
```

正如我们预测的，

- 访问类型变成了一个全表扫描（ALL），现在MySQL预估需要扫描5073条记录来完成这个查询。
- 这里的“Using Where”表示MySQL将通过WHERE条件来筛选存储引擎返回的记录。

一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：

- **在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。**
- **使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。**
- **从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。**

#### 并不是增加索引就能让扫描的行数等于返回的行数

上面这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数COUNT()的查询[(3)](https://www.neat-reader.cn/part0013.xhtml#ch3)：

```sql
SELECT actor_id，COUNT（*） FROM sakila.film_actor GROUP BY actor_id;
```

这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。

不幸的是，MySQL不会告诉我们生成结果实际上需要扫描多少行数据[(4)](https://www.neat-reader.cn/part0013.xhtml#ch4)，而只会告诉我们生成结果时一共扫描了多少行数据。

扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终的结果集并没有贡献。在上面的例子中，我们删除索引后，看到MySQL需要扫描所有记录然后根据WHERE条件过滤，最终只返回10行结果。理解一个查询需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。

## 优化技巧

如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：

- **使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了（在前面的章节中我们已经讨论过了）。**
- 改变库表结构。例如使用单独的汇总表（这是我们在第4章中讨论的办法）。
- 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询（这是本章后续需要讨论的问题）。

