# 032-同步非阻塞IO(NoneBlockingIO)

[TOC]

## 什么是同步非阻塞IO

非阻塞IO,指的是 **用户空间的程序不需要等待内核IO操作彻底完成, 可以立即返回用户空间执行空间执行用户的操作**, 即处于非阻塞的状态, 与此同时, 内核会立即返回给用户一个状态值

简单来说 :

-  阻塞是指用户空间(调用线程) 一直在等待,不能干其别的事, 

-  非阻塞指得是用户空间(调用线程) 拿到内核返回的状态值后就返回到自己的空间, IO可以干就干, 不能干就干别的

非阻塞IO要求socket被设置为NONBLOCK

这里的NIO(同步非阻塞IO) 并不是Java 的 NIO库

## Socket中的同步非阻塞

Socket连接默认是阻塞模式, 在Linux系统下,我们可以通过设置Socket编程非阻塞的模式

在NIO模型中, 应用程序一旦开始IO系统操作, 会出现两种情况

- 在内核缓冲区中没有数据的情况下, 系统会立即返回, 返回一个调用失败的信息
- 在内核缓冲区中有数据的情况下, 是阻塞的,直到数据从内核缓冲复制到用户进程缓冲

复制完成后, 系统调用返回成功, 应用进程开始处理用户空间的缓存数据

![image-20210123193243324](../../../assets/image-20210123193243324.png)

## 非阻塞Socket的read读操作流程

1. 在内核数据没有准备好的阶段, 用户线程发起IO请求时, 立即返回
2. 用户线程不断发送调用IO请求:  为了读取到最终的数据
3. 用户线程读到数据后, 才会解除阻塞状态,重新运行起来, 也就是说, 用户进程需要经过多次尝试, 才能保证最终真正读到的数据, 而后继续执行

## 同步非阻塞IO的特点

- 应用程序的线程需要不断地进行IO调用,轮询数据是否已经准备好了
  - 如果没有准备好则继续轮询
  - 开始阻塞地从内核缓存复制到用户进程

## 同步非阻塞IO(NIO)的优点

- 每次发起IO系统调用, 在内核等待数据过程中可以立即返回, 用户不会阻塞, 实时性比较好

## 同步非阻塞IO(NIO)的缺点

不断地轮询内核, 这将占用大量的CPU时间,效率低下

## 总结

总体来说, 在高并发应用场景下, 同步非阻塞IO也是不可用的, 一般Web服务器不使用这种IO模型

NIO模型一般很少直接使用,而是在其他IO模型中使用到非阻塞IO这一个特性,在Java的实际开发中, 也不会涉及到这种IO模型

## 此NIO非彼NIO

同步非阻塞IO ,简称NIO , 

- 和 Java里的NIO (new IO) 不是一个东西,  Java中的 NIO 是指的IO多路复用模型 (IO Multipexing)
- 和蔚来汽车(NIO) 也不是一个东西 

## 如何解决非阻塞IO中的轮询等待问题呢?

 [033-IO多路复用模型(IOMutiplexing).md](033-IO多路复用模型(IOMutiplexing).md) 

## 支持多路复用调用的类型

目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持

- **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
- **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

## epoll和select模型的区别

I/O多路复用器单个进程可以同时处理多个描述符的I/O, Java应用程序通过调用多路复用器来获取有事件发生的文件描述符， 以进行I/O的读写操作， 多路复用器常见的底层实现模型是epoll和 select 模型

#### select模型

select模型有三个特点

1. select模型只有一个select函数， 每次在调用select函数时， 都需要把整个文件描述符集合从用户态拷贝到内核态， 当文件描述符很多时， 开销会比较大
2. 每次在调用select函数时候， 内核都需要遍历所有的文件描述符， 整个开销也很大， 尤其是当许多文件描述符根本就无状态改变时， 也需要遍历， 浪费性能
3. select 可支持的文件描述符有上线， 可监控的文件描述符个数取决于`sizeOf(fd_set)`的值。 如果`sizeOf(fd_set) = 512` ， 那么服务器就最多支持` 512*8=4096`个文件描述符

#### epoll模型

epoll模型比select模型复杂， 有三个函数

1. 创建一个epoll句柄 

   > int epoll_create(int size)

2. epoll控制函数

   ```
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event*event);
   - 第一个参数epfd 是 调用epoll_create函数返回的值， 标识
   - 第二个参数op 是操作动作，由三个宏来标识
   	- EPOLL_CTL_ADD 注册新的文件描述符到此epfd上
   	- EPOLL_CTL_MOD 标识修改已经注册的文件描述符的监听事件
   	- EPOLL_CTL_DEL 标识从epfd中删除一个文件描述符
   - 第三个参数 fd 为需要监听的文件描述符
   - 第四个参数 表示要监听的事件类型， 事件类型也是几个宏，主要描述文件描述符可读，可写，发生错误，被挂断和触发模式设置等
   ```

3. epoll模型的第三个函数为epoll_wait， 标识等待文件描述符就绪

#### epoll和select的区别

- 所有需要监听的文件描述符只需要在调用第二个函数`int epoll_ctl`时拷贝一次即可， 当文件描述符发生改变时， 内核会把文件描述符放入一个就绪队列中， 通过调用 epoll_wait函数获取就绪的文件描述符
- 每次调用epoll_wait函数只会便利状态发生改变的文件描述符， 无需全部便利， 降低了操作的时间复杂度
- 没有文件描述符个数的限制
- 采用了内存映射机制， 内核直接将就绪队列通过MMAP的方式映射到用户态，避免了内存拷贝带来的额外性能开销
