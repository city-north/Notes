# 033-IO多路复用模型(IOMutiplexing)

[TOC]

## 什么是IO多路复用模型

如何避免 同步非阻塞IO模型中的 轮询等待的问题呢? IO多路复用模型

在IO多路复用模型中, 引入了一种新的系统调用 :  **查询IO的就绪状态**

- Linux系统中对应的系统调用为 select/epoll 系统调用

通过该系统调用, 一个进程可以监视多个文件描述符,

- 一旦某个系统描述符就绪(一般是内核缓冲区 可读/可写), 内核就能将就绪的状态返回给应用程序
- 应用程序根据就绪的状态,进行相应的IO系统调用

## IO多路复用图示

![image-20210203110742336](../../../assets/image-20210203110742336.png)

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。

## select&epoll

- select  系统调用, 几乎在所有的操作系统都有支持, 具有良好的跨平台性能
- epoll 是 Linux 2.6 内核提出的, 是select 系统调用Linux增强版本

在IO多路复用模型中通过 select/epoll 系统调用,单个应用程序的线程, 可以不断地轮询成千上万个select连接

- 当某个或者某些socket 网络连接有IO就绪的状态, 就返回对应的可以执行的读写操作

## IO多路复用模型的例子

发起一个道路复用IO的read操作

1. 选择器注册, 在这种模式下, 首先, 将需要read操作的目标socket网络连接, 提前注册到 select/ epoll 选择器中, Java中对应的选择器类时 Selector 类, 然后, 可以开启整个IO多路复用模型的轮询流程
2. 就绪状态的轮询 : 通过选择器的查询方法, 查询注册过的所有socket 连接的就绪状态, 通过查询的系统调用 , 内核会返回一个就绪的socket 列表, 
   - 当任何一个注册过的socket中的数据准备好了,内核缓冲区就有数据就绪了, 内核就将该socket加入都就绪的列表中
   - 当用户进程调用select 方法, 那么整个县城就会被阻塞掉
3. 用户线程得到就绪状态的列表后, 根据其中的socket连接, 发起read系统调用, 用户线程阻塞, 内核开始复制数据, 将数据从内核缓冲区中复制到用户缓冲区
4. 复制完成后,内核返回结果, 用户线程才会解除阻塞状态,用户线程读取到了数据, 继续执行

## IO多路复用模型的特点

- IO多路复用模型的IO涉及两种系统调用(System Call)
  - 一种是IO操作
  - 一种是select/epoll 就绪查询

- IO多路复用模型和NIO类似
  - 多路复用模型也需要轮询, 负责 select / epoll 状态查询调用的线程, 需要不断地进行 select /epoll 轮询, 查出所有IO就绪的 socket连接
  - 对于注册在选择器上的每一个可以查询的socket连接, 一般设置成为同步非阻塞模型(NIO)

## IO多路复用模型的优点

与一个线程维护一个连接的阻塞IO模式相比, 使用 select/epoll 的最大优势在于, 一个选择器查询线程可以同时处理成千上万个连接(Connection)

系统不必创建大量的线程, 也不必维护这些线程, 从而大大减少了系统的开销

## Java NIO(New IO)就是采用了IO多路复用模型

缺点是, 本质上 slect/epoll 系统调用时阻塞的, 属于同步IO, 都需要在读写事件就绪后, 由系统调用本身负责进行读写, 也就是说这个读写过程是阻塞的

如何彻底地解除线程的阻塞, 就必须使用异步IO模型

[034-异步IO模型(AsynchronousIO).md](034-异步IO模型(AsynchronousIO).md) 

## Java中的选择器

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

![image-20210203110822772](../../../assets/image-20210203110822772.png)