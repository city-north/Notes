# 乐观锁与悲观锁

[TOC]

## 乐观锁

乐观锁乐观地认为自己在读数据时别人不会修改该数据,所以不上锁

- 读取的时候不上锁
- 更新的时候会判断在此期间别人有没有更新该数据 , 通常采用在写方法前先读出当前版本号然后加锁

具体的步骤如下

- 比较当前版本号和上一次的版本号,如果版本号一直,则更新
- 如果版本号不一致则可以重复读取,比较,写操作

Java 中的乐观锁大部分是采用 [ CAS](../03-并发编程的挑战/02-CAS 算法.md)  操作实现的,CAS是一种原子操作,在堆数据操作之前首先会比较当前值跟传入的值是否一样,如果一样则更新,否则不执行,直接返回失败状态 

## 悲观锁

悲观锁采用悲观思想处理数据,在每次读取数据时都认为别人会修改数据

所以每次读取数据之前都会上锁,这样别人想读写这个数据时就会阻塞,等待直到拿到锁

Java 中的悲观锁采用的是 AQS(AbstractQueuedSynchronzied, 抽象队列同步器)实现

AQS 定义了一套多线程访问数据资源的同步框架,许多同步类的实现都依赖它,例如

-  [Synchronized](../04-Java并发机制的底层实现原理/02-synchronized的实现原理与应用.md) 
-  [ReentrantLock](06-ReentrantLock.md) 
-  [Semaphore](../10-Java中的并发工具类/03-信号量-Semaphore.md) 
-  [CountDownLatch](../10-Java中的并发工具类/01-CountDownLatch.md)  
- [CyclicBarrier](../10-Java中的并发工具类/02-同步屏障-CyclicBarrier.md) 

该框架的锁会优先尝试 CAS 乐观获取锁,如果获取不到,则转为悲观锁