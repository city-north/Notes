# AQS 共享资源的方式: 独占式和共享锁

[TOC]

## 独占式和共享锁

AQS定义了两种资源共享方式: 独立式 **(Exclusive)** 和共享式 (Share)

- 独立式: 只有一个线程能够执行,具体的 Java 实现由 `ReentrentLock`

  > 具体的操作为
  >
  > - tryAcquire 独占获取
  > - tryRelease 独占释放

- 共享式: 多个线程可同时执行,具体的 Java 实现由 `Semaphore` 和 `CountDownLatch`

  > 具体的操作为
  >
  > - tryAcquireShared 共享获取
  > - tryReleaseShared 共享释放

**AQS 仅仅只是一个框架,定义了一个接口**,具体资源的获取,释放都交给自定义同步器去实现,不同的自定义同步器征用共享资源的方式也不同,自定义同步器在实现时只需要实现共享资源 state 的获取和释放方式即可,至于具体线程等待队列的维护,如获取资源失败入队,唤醒出队等,AQS已经在顶层实现好了,不需要具体的同步器再处理,需要实现的方法如下:

| 序号 | 方法名                      | 资源共享方式 | 说明                                                         |
| ---- | --------------------------- | ------------ | ------------------------------------------------------------ |
| 1    | `isHeldExclusively`         |              | 查询该线程是否正在独占资源,只有用到 condition 才需要去实现它 |
| 2    | `tryAcquire(int)`           | 独占方式     | 尝试获取资源,成功返回 true, 失败返回 false                   |
| 3    | `tryRelease(int arg)`       | 独占方式     | 尝试释放资源,成功返回 true, 失败返回 false                   |
| 4    | `tryAcquireShared(int arg)` | 共享方式     | 尝试获取资源,负数代表失败,0 代表成功,但是没有剩余可用资源;整数表示成功,且有剩余 |
| 5    | `tryReleaseShared(int arg)` | 共享方式     | 铲屎释放资源,如果释放资源后允许唤醒后续等待线程,返回 true.否则返回 false |