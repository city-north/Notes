[返回目录](/README.md)

# 局部变量

我们迄今为止所介绍的所有Lambda表达式都只用到了其主体里面的参数。但Lambda表达式  
也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被  
称作**捕获Lambda**。例如，下面的Lambda捕获了portNumber 变量：

```
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

尽管如此，还有一点点小麻烦：关于能对这些变量做什么有一些限制。Lambda可以没有限  
制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，  
或事实上是 final 。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获  
实例变量可以被看作捕获最终局部变量 this 。） 例如，下面的代码无法编译，因为 portNumber  
变量被赋值两次

```
变量被赋值两次：
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 31337;
```

错误：Lambda表达式引用的局  
部变量必须是最终的（ final ）

或事实上最终的

## 对局部变量的限制

为什么局部变量有这些限制：

1. 实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果ambda可以直接访问局
   部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线
   程将这个变量收回之后，去访问该变量。
2. 这一限制不鼓励你使用改变外部变量的典型命令式编程模式（我们会在以后的各章中
   解释，这种模式会阻碍很容易做到的并行处理）。

## 闭包

你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。

用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。

例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。

现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是隐式最终的。可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的）

[返回目录](#)

